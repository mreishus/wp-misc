#!/usr/bin/env python3
import subprocess
import statistics
import argparse
from urllib.parse import urlparse
import re
import random
import string
import json

def generate_random_chars(length=8):
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))

def make_curl_request(url, use_dns_override):
    hostname = urlparse(url).hostname
    port = urlparse(url).port or ('443' if url.startswith('https') else '80')
    random_chars = generate_random_chars()
    if '?' in url:
        url += f'&defeatcache={random_chars}'
    else:
        url += f'?defeatcache={random_chars}'
    
    command = [
        'curl',
        '-k',
        '--ipv4',
        '-i',
        '-w', '\\n%{http_code} %{time_starttransfer}',  # Output HTTP status code and TTFB
        '-s',  # Silent mode
    ]

    if use_dns_override:
        resolve_param = f"{hostname}:{port}:127.0.0.1"
        command.extend(['--resolve', resolve_param])  # DNS resolution override
    
    command.append(url)
    
    result = subprocess.run(command, capture_output=True, text=True)
    
    if result.returncode == 0:
        headers_body, http_code_ttfb = result.stdout.rsplit('\n', 1)
        http_code, ttfb = http_code_ttfb.split()
        http_code = int(http_code)
        ttfb = float(ttfb.strip())
        if http_code != 200:
            print(f"Warning: Received non-200 HTTP status code: {http_code}")
            return None
        if re.search("fatal error", headers_body, re.IGNORECASE):
            print("Warning: 'Fatal Error' found in the response body or headers.")
            return None
        return ttfb
    else:
        print(f"Error: Command failed with return code {result.returncode}")
        print(f"Stdout: {result.stdout}")
        print(f"Stderr: {result.stderr}")
        return None

def measure_ttfb(url, num_requests, use_dns_override, output_format='text'):
    ttfbs = []
    data = {
        'url': url,
        'metrics': {},
        'requests': [],
        'buckets': {}
    }

    for i in range(num_requests):
        if output_format == 'text':
            print(f"Making request {i + 1} of {num_requests}", end='\r')
        ttfb = make_curl_request(url, use_dns_override)
        if ttfb is not None:
            ttfbs.append(ttfb)
            data['requests'].append(ttfb)
    
    if ttfbs:
        ttfbs.sort()
        data['metrics'] = {
            'min': min(ttfbs),
            'max': max(ttfbs),
            'avg': sum(ttfbs) / len(ttfbs),
            'stddev': statistics.stdev(ttfbs),
            'p50': ttfbs[int(len(ttfbs) * 0.50)],
            'p75': ttfbs[int(len(ttfbs) * 0.75)],
            'p90': ttfbs[int(len(ttfbs) * 0.90)],
            'p95': ttfbs[int(len(ttfbs) * 0.95)],
            'p99': ttfbs[int(len(ttfbs) * 0.99)]
        }
        
        # Bucketing
        delta = 0.1
        for ttfb in ttfbs:
            bucket = round(int(ttfb / delta) * delta, 1)
            data['buckets'][str(bucket)] = data['buckets'].get(str(bucket), 0) + 1

        if output_format == 'json':
            print(json.dumps(data, indent=2))
        else:
            display_text_output(data, num_requests, use_dns_override)

def display_text_output(data, num_requests, use_dns_override):
    print("\n\n*** TTFB of {0} requests, in seconds ***\n".format(num_requests))
    print(f"DNS Override: {'Enabled' if use_dns_override else 'Disabled'}")
    print(f"min = {data['metrics']['min']:.4f}")
    print(f"avg = {data['metrics']['avg']:.4f}")
    print(f"max = {data['metrics']['max']:.4f}")
    print(f"stddev = {data['metrics']['stddev']:.4f}")
    print("")
    for key in ['p50', 'p75', 'p90', 'p95', 'p99']:
        print(f"{key} = {data['metrics'][key]:.4f}")

    print("\n*** Buckets ***\n")
    for bucket, count in sorted(data['buckets'].items(), key=lambda x: float(x[0])):
        print(f"| {float(bucket):.1f} -> {float(bucket) + 0.1:.1f} = {count}")

def parse_arguments():
    parser = argparse.ArgumentParser(description="Measure Time to First Byte (TTFB) using curl with optional DNS overrides.")
    parser.add_argument('url', type=str, help="URL to request")
    parser.add_argument('num_requests', type=int, help="Number of requests to send")
    parser.add_argument('--disable-dns-override', action='store_true', help="Disable automatic DNS override")
    parser.add_argument('-f', '--format', choices=['text', 'json'], default='text', help="Output format (text or json)")
    args = parser.parse_args()
    return args.url, args.num_requests, not args.disable_dns_override, args.format

def main():
    url, num_requests, use_dns_override, output_format = parse_arguments()
    measure_ttfb(url, num_requests, use_dns_override, output_format)

if __name__ == "__main__":
    main()
